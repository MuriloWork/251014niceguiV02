Configuration & Deployment

You can access the list of all URLs on which the NiceGUI app is available via `app.urls`. The URLs are not available in `app.on_startup` because the server is not yet running. Instead, you can access them in a page function or register a callback with `app.urls.on_change`.

You can call ui.run() with optional arguments. Most of them only apply after stopping and fully restarting the app and do not apply with auto-reloading.

|     |     |
| --- | --- | 
| root: | root page function (*added in version 3.0.0*) |
| host: | start server with this host (defaults to '127.0.0.1 in native mode, otherwise '0.0.0.0') |
| port: | use this port (default: 8080 in normal mode, and an automatically determined open port in native mode) |
| title: | page title (default: 'NiceGUI', can be overwritten per page) |
| viewport: | page meta viewport content (default: 'width=device-width, initial-scale=1', can be overwritten per page) |
| favicon: | relative filepath, absolute URL to a favicon (default: None, NiceGUI icon will be used) or emoji (e.g. 'ðŸš€', works for most browsers) |
| dark: | whether to use Quasar's dark mode (default: False, use None for "auto" mode) |
| language: | language for Quasar elements (default: 'en-US') |
| binding_refresh_interval: |     |
|     | time between binding updates (default: 0.1 seconds, bigger is more CPU friendly) |
| reconnect_timeout: |     |
|     | maximum time the server waits for the browser to reconnect (default: 3.0 seconds) |
| message_history_length: |     |
|     | maximum number of messages that will be stored and resent after a connection interruption (default: 1000, use 0 to disable, *added in version 2.9.0*) |
| cache_control_directives: |     |
|     | cache control directives for internal static files (default: 'public, max-age=31536000, immutable, stale-while-revalidate=31536000') |
| fastapi_docs: | enable FastAPI's automatic documentation with Swagger UI, ReDoc, and OpenAPI JSON (bool or dictionary as described [here](https://fastapi.tiangolo.com/tutorial/metadata/), default: False, *updated in version 2.9.0*) |
| show: | automatically open the UI in a browser tab (default: True) |
| on_air: | tech preview: [allows temporary remote access](https://nicegui.io/documentation/section_configuration_deployment#nicegui_on_air) if set to True (default: disabled) |
| native: | open the UI in a native window of size 800x600 (default: False, deactivates show, automatically finds an open port) |
| window_size: | open the UI in a native window with the provided size (e.g. (1024, 786), default: None, also activates native) |
| fullscreen: | open the UI in a fullscreen window (default: False, also activates native) |
| frameless: | open the UI in a frameless window (default: False, also activates native) |
| reload: | automatically reload the UI on file changes (default: True) |
| uvicorn_logging_level: |     |
|     | logging level for uvicorn server (default: 'warning') |
| uvicorn_reload_dirs: |     |
|     | string with comma-separated list for directories to be monitored (default is current working directory only) |
| uvicorn_reload_includes: |     |
|     | string with comma-separated list of glob-patterns which trigger reload on modification (default: '\*.py') |
| uvicorn_reload_excludes: |     |
|     | string with comma-separated list of glob-patterns which should be ignored for reload (default: '.\*, .py\[cod\], .sw.\*, ~\*') |
| tailwind: | whether to use Tailwind (experimental, default: True) |
| prod_js: | whether to use the production version of Vue and Quasar dependencies (default: True) |
| endpoint_documentation: |     |
|     | control what endpoints appear in the autogenerated OpenAPI docs (default: 'none', options: 'none', 'internal', 'page', 'all') |
| storage_secret: | secret key for browser-based storage (default: None, a value is required to enable ui.storage.individual and ui.storage.browser) |
| show_welcome_message: |     |
|     | whether to show the welcome message (default: True) |
| kwargs: | additional keyword arguments are passed to uvicorn.run |

You can enable native mode for NiceGUI by specifying `native=True` in the `ui.run` function. To customize the initial window size and display mode, use the `window_size` and `fullscreen` parameters respectively. Additionally, you can provide extra keyword arguments via `app.native.window_args` and `app.native.start_args`. Pick any parameter as it is defined by the internally used [pywebview module](https://pywebview.flowrl.com/api) for the `webview.create_window` and `webview.start` functions. Note that these keyword arguments will take precedence over the parameters defined in `ui.run`.

Additionally, you can change `webview.settings` via `app.native.settings`.

In native mode the `app.native.main_window` object allows you to access the underlying window. It is an async version of [`Window` from pywebview](https://pywebview.flowrl.com/api/#webview-window).

Note that the native app is run in a separate [process](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process). Therefore any configuration changes from code run under a [main guard](https://docs.python.org/3/library/__main__.html#idiomatic-usage) is ignored by the native app. The following examples show the difference between a working and a non-working configuration.

If webview has trouble finding required libraries, you may get an error relating to "WebView2Loader.dll". To work around this issue, try moving the DLL file up a directory, e.g.:

- from `.venv/Lib/site-packages/webview/lib/x64/WebView2Loader.dll`
- to `.venv/Lib/site-packages/webview/lib/WebView2Loader.dll`

You can set the following environment variables to configure NiceGUI:

- `MATPLOTLIB` (default: true) can be set to `false` to avoid the potentially costly import of Matplotlib. This will make `ui.pyplot` and `ui.line_plot` unavailable.
- `NICEGUI_STORAGE_PATH` (default: local ".nicegui") can be set to change the location of the storage files.
- `MARKDOWN_CONTENT_CACHE_SIZE` (default: 1000): The maximum number of Markdown content snippets that are cached in memory.
- `RST_CONTENT_CACHE_SIZE` (default: 1000): The maximum number of ReStructuredText content snippets that are cached in memory.
- `NICEGUI_REDIS_URL` (default: None, means local file storage): The URL of the Redis server to use for shared persistent storage.
- `NICEGUI_REDIS_KEY_PREFIX` (default: "nicegui:"): The prefix for Redis keys.

`background_tasks.create()` allows you to run an async function in the background and return a task object. By default the task will be automatically cancelled during shutdown. You can prevent this by using the `@background_tasks.await_on_shutdown` decorator (added in version 2.16.0). This is useful for tasks that need to be completed even when the app is shutting down.

You can create custom components by subclassing `ui.element` and implementing a corresponding Vue component. The ["Custom Vue components" example](https://github.com/zauberzeug/nicegui/tree/main/examples/custom_vue_component) demonstrates how to create a custom counter component which emits events and receives updates from the server.

The ["Signature pad" example](https://github.com/zauberzeug/nicegui/blob/main/examples/signature_pad) and the ["Node module integration" example](https://github.com/zauberzeug/nicegui/blob/main/examples/node_module_integration) demonstrate how to bundle a custom Vue component with its dependencies defined in a `package.json` file. In Python we can use the `esm` parameter when subclassing `ui.element` to specify the ESM module name and the path to the bundled component. This adds the ESM module to the import map of the page and makes it available in the Vue component.

To deploy your NiceGUI app on a server, you will need to execute your `main.py` (or whichever file contains your `ui.run(...)`) on your cloud infrastructure. You can, for example, just install the [NiceGUI python package via pip](https://pypi.org/project/nicegui/) and use systemd or similar service to start the main script. In most cases, you will set the port to 80 (or 443 if you want to use HTTPS) with the `ui.run` command to make it easily accessible from the outside.

A convenient alternative is the use of our [pre-built multi-arch Docker image](https://hub.docker.com/r/zauberzeug/nicegui) which contains all necessary dependencies. With this command you can launch the script `main.py` in the current directory on the public port 80:

The demo assumes `main.py` uses the port 8080 in the `ui.run` command (which is the default). The `-d` tells docker to run in background and `--restart always` makes sure the container is restarted if the app crashes or the server reboots. Of course this can also be written in a Docker compose file:

There are other handy features in the Docker image like non-root user execution and signal pass-through. For more details we recommend to have a look at our [Docker example](https://github.com/zauberzeug/nicegui/tree/main/examples/docker_image).

To serve your application with [HTTPS](https://fastapi.tiangolo.com/deployment/https/) encryption, you can provide SSL certificates in multiple ways. For instance, you can directly provide your certificates to [Uvicorn](https://www.uvicorn.org/), which NiceGUI is based on, by passing the relevant [options](https://www.uvicorn.org/#command-line-options) to `ui.run()`. If both a certificate and key file are provided, the application will automatically be served over HTTPS:

NiceGUI apps can also be bundled into an executable with `nicegui-pack` which is based on [PyInstaller](https://www.pyinstaller.org/). This allows you to distribute your app as a single file that can be executed on any computer.

Just make sure to call `ui.run` with `reload=False` in your main script to disable the auto-reload feature. Running the `nicegui-pack` command below will create an executable `myapp` in the `dist` folder:

**Packaging Tips:**

- When building a PyInstaller app, your main script can use a native window (rather than a browser window) by using `ui.run(reload=False, native=True)`. The `native` parameter can be `True` or `False` depending on whether you want a native window or to launch a page in the user's browser - either will work in the PyInstaller generated app.
    
- Specifying `--windowed` to `nicegui-pack` will prevent a terminal console from appearing. However you should only use this option if you have also specified `native=True` in your `ui.run` command. Without a terminal console the user won't be able to exit the app by pressing Ctrl-C. With the `native=True` option, the app will automatically close when the window is closed, as expected.
    
- Specifying `--windowed` to `nicegui-pack` will create an `.app` file on Mac which may be more convenient to distribute. When you double-click the app to run it, it will not show any console output. You can also run the app from the command line with `./myapp.app/Contents/MacOS/myapp` to see the console output.
    
- Specifying `--onefile` to `nicegui-pack` will create a single executable file. Whilst convenient for distribution, it will be slower to start up. This is not NiceGUI's fault but just the way Pyinstaller zips things into a single file, then unzips everything into a temporary directory before running. You can mitigate this by removing `--onefile` from the `nicegui-pack` command, and zip up the generated `dist` directory yourself, distribute it, and your end users can unzip once and be good to go, without the constant expansion of files due to the `--onefile` flag.
    
- Summary of user experience for different options:
    
    | `nicegui-pack` | `ui.run(...)` | Explanation |
    | --- | --- | --- |
    | `onefile` | `native=False` | Single executable generated in `dist/`, runs in browser |
    | `onefile` | `native=True` | Single executable generated in `dist/`, runs in popup window |
    | `onefile` and `windowed` | `native=True` | Single executable generated in `dist/` (on Mac a proper `dist/myapp.app` generated incl. icon), runs in popup window, no console appears |
    | `onefile` and `windowed` | `native=False` | Avoid (no way to exit the app) |
    | Specify neither |     | A `dist/myapp` directory created which can be zipped manually and distributed; run with `dist/myapp/myapp` |
    
- If you are using a Python virtual environment, ensure you `pip install pyinstaller` within your virtual environment so that the correct PyInstaller is used, or you may get broken apps due to the wrong version of PyInstaller being picked up. That is why the `nicegui-pack` invokes PyInstaller using `python -m PyInstaller` rather than just `pyinstaller`.
    

Note: If you're getting an error "TypeError: a bytes-like object is required, not 'str'", try adding the following lines to the top of your `main.py` file:

`import syssys.stdout = open('logs.txt', 'w')`

See https://github.com/zauberzeug/nicegui/issues/681 for more information.

**macOS Packaging**

Add the following snippet before anything else in your main app's file, to prevent new processes from being spawned in an endless loop:

`# macOS packaging supportfrom multiprocessing import freeze_support  # noqafreeze_support()  # noqa# all your other imports and code`

The `# noqa` comment instructs Pylance or autopep8 to not apply any PEP rule on those two lines, guaranteeing they remain on top of anything else. This is key to prevent process spawning.

By using `ui.run(on_air=True)` you can share your local app with others over the internet ðŸ§ž.

When accessing the on-air URL, all libraries (like Vue, Quasar, ...) are loaded from our CDN. Thereby only the raw content and events need to be transmitted by your local app. This makes it blazing fast even if your app only has a poor internet connection (e.g. a mobile robot in the field).

By setting `on_air=True` you will get a random URL which is valid for 1 hour. If you sign-up at [https://on-air.nicegui.io](https://on-air.nicegui.io/), you can setup an organization and device name to get a fixed URL: `https://on-air.nicegui.io/<my-org>/<my_device_name>`. The device is then identified by a unique, private token which you can use instead of a boolean flag: `ui.run(on_air='<your token>')`. If you [sponsor us](https://github.com/sponsors/zauberzeug), we will enable multi-device management and provide built-in passphrase protection for each device.

Currently On Air is available as a tech preview and can be used free of charge. We will gradually improve stability and extend the service with usage statistics, remote terminal access and more. Please let us know your feedback on [GitHub](https://github.com/zauberzeug/nicegui/discussions), [Reddit](https://www.reddit.com/r/nicegui/), or [Discord](https://discord.gg/TEpFeAaF4f).

**Data Privacy:** We take your privacy very serious. NiceGUI On Air does not log or store any content of the relayed data.